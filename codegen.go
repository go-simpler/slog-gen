package main

import (
	"bytes"
	"cmp"
	"fmt"
	"go/format"
	"io"
	"slices"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

var tmpl = template.Must(template.New("").Funcs(funcs).Parse(
	`// Code generated by go-simpler.org/slog-gen. DO NOT EDIT.

package {{.Pkg}}

{{range .Imports -}}
import "{{.}}"
{{end}}

{{range $_, $lvl := .Levels -}}
const Level{{snakeToCamel .Name}} = slog.Level({{.Severity}})
{{end}}

{{range .Consts -}}
const {{snakeToCamel .}} = "{{.}}"
{{end}}

{{range $_, $attr := .Attrs}}
func {{snakeToCamel $attr.Key}}(value {{$attr.Type}}) slog.Attr {
	return slog.{{slogFunc $attr.Type}}("{{$attr.Key}}", value)
}
{{end}}`,
))

//nolint:staticcheck // SA1019: strings.Title is deprecated but works just fine here.
var funcs = template.FuncMap{
	"snakeToCamel": func(s string) string {
		parts := strings.Split(s, "_")
		for i := range parts {
			parts[i] = strings.Title(parts[i])
		}
		return strings.Join(parts, "")
	},
	"slogFunc": func(typ string) string {
		switch s := strings.Title(strings.TrimPrefix(typ, "time.")); s {
		case "String", "Int64", "Int", "Uint64", "Float64", "Bool", "Time", "Duration":
			return s
		default:
			return "Any"
		}
	},
}

type (
	config struct {
		Pkg     string
		Imports []string
		Levels  []level
		Consts  []string
		Attrs   []attr
	}
	level struct {
		Name     string
		Severity int
	}
	attr struct {
		Key  string
		Type string
	}
)

func readConfig(r io.Reader) (*config, error) {
	cfg := struct {
		Pkg     string            `yaml:"pkg"`
		Imports []string          `yaml:"imports"`
		Levels  map[string]int    `yaml:"levels"` // name:severity
		Consts  []string          `yaml:"consts"`
		Attrs   map[string]string `yaml:"attrs"` // key:type
	}{
		Pkg: "log",
	}
	if err := yaml.NewDecoder(r).Decode(&cfg); err != nil {
		return nil, fmt.Errorf("decoding config: %w", err)
	}

	if len(cfg.Attrs) > 0 || len(cfg.Levels) > 0 {
		cfg.Imports = append(cfg.Imports, "log/slog")
	}

	slices.Sort(cfg.Imports)
	slices.Sort(cfg.Consts)

	names := mapKeys(cfg.Levels)
	levels := make([]level, len(names))
	for i, name := range names {
		levels[i] = level{Name: name, Severity: cfg.Levels[name]}
	}
	slices.SortFunc(levels, func(lvl1, lvl2 level) int {
		return cmp.Compare(lvl1.Severity, lvl2.Severity)
	})

	keys := mapKeys(cfg.Attrs)
	attrs := make([]attr, len(keys))
	for i, key := range keys {
		attrs[i] = attr{Key: key, Type: cfg.Attrs[key]}
	}

	return &config{
		Pkg:     cfg.Pkg,
		Imports: cfg.Imports,
		Levels:  levels,
		Consts:  cfg.Consts,
		Attrs:   attrs,
	}, nil
}

func writeCode(w io.Writer, cfg *config) error {
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, cfg); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting code: %w", err)
	}

	if _, err := w.Write(src); err != nil {
		return fmt.Errorf("writing code: %w", err)
	}

	return nil
}

// TODO: replace with maps.Keys() when it is released.
func mapKeys[T any](m map[string]T) []string {
	keys := make([]string, 0, len(m))
	for key := range m {
		keys = append(keys, key)
	}
	slices.Sort(keys)
	return keys
}
