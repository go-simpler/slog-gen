package main

import (
	"bytes"
	"cmp"
	"fmt"
	"go/format"
	"io"
	"log/slog"
	"slices"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

var tmpl = template.Must(template.New("").Funcs(funcs).Parse(
	`// Code generated by go-simpler.org/sloggen. DO NOT EDIT.

package {{$.Pkg}}

{{range $.Imports -}}
import "{{.}}"
{{end}}

{{range $.Levels -}}
const Level{{title .Name}} = slog.Level({{.Severity}})
{{end}}

{{range $.Consts -}}
const {{snakeToCamel .}} = "{{.}}"
{{end}}

{{range $.Attrs -}}
func {{snakeToCamel .Key}}(value {{.Type}}) slog.Attr { return slog.{{slogFunc .Type}}("{{.Key}}", value) }
{{end}}

{{if $.HasCustomLevels}}
func ParseLevel(s string) (slog.Level, error) {
	switch strings.ToUpper(s) {
	{{range $.Levels -}}
	case "{{upper .Name}}":
		return Level{{title .Name}}, nil
	{{end -}}
	default:
		return 0, fmt.Errorf("slog: level string %q: unknown name", s)
	}
}

func ReplaceAttr(_ []string, attr slog.Attr) slog.Attr {
	if attr.Key != slog.LevelKey {
		return attr
	}
	switch attr.Value.Any().(slog.Level) {
	{{range $.Levels -}}
	case Level{{title .Name}}:
		attr.Value = slog.StringValue("{{upper .Name}}")
	{{end -}}
	}
	return attr
}
{{end}}

{{if $l := $.Logger}}
type Logger struct{ Logger *slog.Logger }
{{range $l.Levels}}
func (l *Logger) {{title .Name}}({{if $l.Context}}ctx context.Context, {{end}}msg string, {{if $l.AttrAPI}}attrs ...slog.Attr{{else}}args ...any{{end}}) {
	l.log({{if $l.Context}}ctx{{else}}context.Background(){{end}}, {{if not $.HasCustomLevels}}slog.{{end}}Level{{title .Name}}, msg, {{if $l.AttrAPI}}attrs{{else}}args{{end}})
}
{{end}}
func (l *Logger) log(ctx context.Context, level slog.Level, msg string, {{if $l.AttrAPI}}attrs []slog.Attr{{else}}args []any{{end}}) {
	if !l.Logger.Enabled(ctx, level) {
		return
	}
	var pcs [1]uintptr
	runtime.Callers(3, pcs[:])
	r := slog.NewRecord(time.Now(), level, msg, pcs[0])
	r.Add{{if $l.AttrAPI}}Attrs(attrs...){{else}}(args...){{end}}
	_ = l.Logger.Handler().Handle(ctx, r)
}
{{end}}`,
))

//nolint:staticcheck // SA1019: strings.Title is deprecated but works just fine here.
var funcs = template.FuncMap{
	"title": strings.Title,
	"upper": strings.ToUpper,
	"snakeToCamel": func(s string) string {
		parts := strings.Split(s, "_")
		for i := range parts {
			parts[i] = strings.Title(parts[i])
		}
		return strings.Join(parts, "")
	},
	"slogFunc": func(typ string) string {
		switch s := strings.Title(strings.TrimPrefix(typ, "time.")); s {
		case "String", "Int64", "Int", "Uint64", "Float64", "Bool", "Time", "Duration":
			return s
		default:
			return "Any"
		}
	},
}

type (
	config struct {
		Pkg             string
		Imports         []string
		Levels          []level
		Consts          []string
		Attrs           []attr
		Logger          *logger
		HasCustomLevels bool
	}
	level struct {
		Name     string
		Severity int
	}
	attr struct {
		Key  string
		Type string
	}
	logger struct {
		Levels  []level
		AttrAPI bool
		Context bool
	}
)

func readConfig(r io.Reader) (*config, error) {
	var data struct {
		Pkg     string              `yaml:"pkg"`
		Imports []string            `yaml:"imports"`
		Levels  []map[string]int    `yaml:"levels"` // name:severity
		Consts  []string            `yaml:"consts"`
		Attrs   []map[string]string `yaml:"attrs"` // key:type
		Logger  *struct {
			API     string `yaml:"api"`
			Context bool   `yaml:"context"`
		} `yaml:"logger"`
	}
	if err := yaml.NewDecoder(r).Decode(&data); err != nil {
		return nil, fmt.Errorf("decoding config: %w", err)
	}

	cfg := config{
		Pkg:             data.Pkg,
		Imports:         data.Imports,
		Levels:          make([]level, len(data.Levels)),
		Consts:          data.Consts,
		Attrs:           make([]attr, len(data.Attrs)),
		Logger:          nil,
		HasCustomLevels: false,
	}
	if cfg.Pkg == "" {
		cfg.Pkg = "slogx"
	}

	for i, m := range data.Levels {
		name, severity := getKV(m)
		cfg.Levels[i] = level{name, severity}

		switch slog.Level(severity) {
		case slog.LevelDebug, slog.LevelInfo, slog.LevelWarn, slog.LevelError:
		default:
			cfg.HasCustomLevels = true
		}
	}
	slices.SortFunc(cfg.Levels, func(l1, l2 level) int {
		return cmp.Compare(l1.Severity, l2.Severity)
	})

	for i, m := range data.Attrs {
		key, typ := getKV(m)
		cfg.Attrs[i] = attr{key, typ}
	}
	slices.SortFunc(cfg.Attrs, func(a1, a2 attr) int {
		return cmp.Compare(a1.Key, a2.Key)
	})

	if data.Logger != nil {
		cfg.Logger = &logger{
			Levels:  cfg.Levels,
			AttrAPI: false,
			Context: data.Logger.Context,
		}

		if len(cfg.Levels) == 0 {
			cfg.Logger.Levels = []level{
				{"debug", int(slog.LevelDebug)},
				{"info", int(slog.LevelInfo)},
				{"warn", int(slog.LevelWarn)},
				{"error", int(slog.LevelError)},
			}
		}

		switch data.Logger.API {
		case "any":
		case "attr":
			cfg.Logger.AttrAPI = true
		default:
			return nil, fmt.Errorf("sloggen: %q: invalid logger.api value", data.Logger.API)
		}
	}

	if len(cfg.Attrs) > 0 || len(cfg.Levels) > 0 || cfg.Logger != nil {
		cfg.Imports = append(cfg.Imports, "log/slog")
	}
	if cfg.HasCustomLevels {
		cfg.Imports = append(cfg.Imports, "fmt", "strings")
	}
	if cfg.Logger != nil {
		cfg.Imports = append(cfg.Imports, "context", "runtime")
	}

	slices.Sort(cfg.Consts)
	slices.Sort(cfg.Imports)
	cfg.Imports = slices.Compact(cfg.Imports)

	return &cfg, nil
}

func writeCode(w io.Writer, cfg *config) error {
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, cfg); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting code: %w", err)
	}

	if _, err := w.Write(src); err != nil {
		return fmt.Errorf("writing code: %w", err)
	}

	return nil
}

//nolint:gocritic // unnamedResult: generics false positive.
func getKV[V any](m map[string]V) (string, V) {
	for k, v := range m {
		return k, v
	}
	return "", *new(V)
}
