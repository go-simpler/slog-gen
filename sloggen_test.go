package main

import (
	"bytes"
	"context"
	"log/slog"
	"path/filepath"
	"strings"
	"testing"

	"go-simpler.org/assert"
	. "go-simpler.org/assert/EF"
	"go-simpler.org/sloggen/example"
)

//go:generate go run main.go sloggen.go --config=.slog.example.yml

var cfg = config{
	Pkg:     "test",
	Imports: []string{"fmt", "log/slog", "strings", "time"},
	Levels:  map[int]string{1: "custom"},
	Consts:  []string{"foo"},
	Attrs: map[string]string{
		"bar": "time.Time",
		"baz": "time.Duration",
	},
}

func Test_readFlags(t *testing.T) {
	args := []string{
		"-pkg=test",
		"-i=time",
		"-l=custom:1",
		"-c=foo",
		"-a=bar:time.Time",
		"-a=baz:time.Duration",
	}

	got, err := readFlags(args)
	assert.NoErr[F](t, err)
	assert.Equal[E](t, got, &cfg)
}

func Test_readConfig(t *testing.T) {
	r := strings.NewReader(`
pkg: test
imports:
  - time
levels:
  - custom: 1
consts:
  - foo
attrs:
  - bar: time.Time
  - baz: time.Duration
`)

	got, err := readConfig(r)
	assert.NoErr[F](t, err)
	assert.Equal[E](t, got, &cfg)
}

func Test_writeCode(t *testing.T) {
	const src = `// Code generated by go-simpler.org/sloggen. DO NOT EDIT.

package test

import "fmt"
import "log/slog"
import "strings"
import "time"

const LevelCustom = slog.Level(1)

const Foo = "foo"

func Bar(value time.Time) slog.Attr     { return slog.Time("bar", value) }
func Baz(value time.Duration) slog.Attr { return slog.Duration("baz", value) }

func ParseLevel(s string) (slog.Level, error) {
	switch strings.ToUpper(s) {
	case "CUSTOM":
		return LevelCustom, nil
	default:
		return 0, fmt.Errorf("slog: level string %q: unknown name", s)
	}
}

func ReplaceAttr(_ []string, attr slog.Attr) slog.Attr {
	if attr.Key != slog.LevelKey {
		return attr
	}
	switch attr.Value.Any().(slog.Level) {
	case LevelCustom:
		attr.Value = slog.StringValue("CUSTOM")
	}
	return attr
}
`
	var buf bytes.Buffer
	err := writeCode(&buf, &cfg)
	assert.NoErr[F](t, err)
	assert.Equal[E](t, buf.String(), src)
}

func TestExample(t *testing.T) {
	replaceAttr := func(groups []string, attr slog.Attr) slog.Attr {
		if attr.Key == slog.TimeKey {
			return slog.Attr{}
		}
		if attr.Key == slog.SourceKey {
			src := attr.Value.Any().(*slog.Source)
			src.File = filepath.Base(src.File)
		}
		return example.ReplaceAttr(groups, attr)
	}

	var buf bytes.Buffer
	handler := slog.NewTextHandler(&buf, &slog.HandlerOptions{
		AddSource:   true,
		Level:       example.LevelInfo,
		ReplaceAttr: replaceAttr,
	})

	logger := example.New(handler).
		WithGroup("group").
		With(slog.String("key", "value"))

	level, err := example.ParseLevel("ALERT")
	assert.NoErr[F](t, err)
	assert.Equal[E](t, level, example.LevelAlert)

	ctx := context.Background()
	enabled := logger.Enabled(ctx, level)
	assert.Equal[E](t, enabled, true)

	logger.Info(ctx, "foo")
	logger.Alert(ctx, "bar")
	logger.Log(ctx, level, "baz")
	assert.Equal[E](t, "\n"+buf.String(), `
level=INFO source=sloggen_test.go:137 msg=foo group.key=value
level=ALERT source=sloggen_test.go:138 msg=bar group.key=value
level=ALERT source=sloggen_test.go:139 msg=baz group.key=value
`)
}
